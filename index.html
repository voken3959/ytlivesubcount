/****************** CONFIG - change these if you like ******************/
const API_KEY = "AIzaSyCW77DSG7oowEV_iOg0K_wgJjBzM8Lzs"; // <- REPLACE with your key
const MAX_RESULTS = 8;                   // search results to show
const POLL_INTERVAL = 1_000;            // ms between exact API polls
const SIM_TICK = 5000;                   // ms between UI simulation ticks
const DEFAULT_MILESTONES = [10000, 50000, 100000, 250000, 500000, 1000000];
/************************************************************************/

// utils
const el = id => document.getElementById(id);
const fmt = n => (typeof n === "number") ? n.toLocaleString() : n;

// safe storage helpers
const storageKey = cid => `yt_sim_state_${cid}`;
function saveStateToLocal(channelId, state) {
  try { localStorage.setItem(storageKey(channelId), JSON.stringify(state)); } catch(e) {}
}
function loadStateFromLocal(channelId) {
  try { const s = localStorage.getItem(storageKey(channelId)); return s ? JSON.parse(s) : null; } catch(e){ return null; }
}

// Levenshtein distance (for fuzzy sorting)
function levenshtein(a, b) {
  a = (a||"").toLowerCase(); b = (b||"").toLowerCase();
  if (a === b) return 0;
  const m = a.length, n = b.length;
  const dp = Array.from({length: m+1}, () => new Array(n+1));
  for (let i=0;i<=m;i++) dp[i][0] = i;
  for (let j=0;j<=n;j++) dp[0][j] = j;
  for (let i=1;i<=m;i++){
    for (let j=1;j<=n;j++){
      dp[i][j] = Math.min(
        dp[i-1][j] + 1,
        dp[i][j-1] + 1,
        dp[i-1][j-1] + (a[i-1]===b[j-1] ? 0 : 1)
      );
    }
  }
  return dp[m][n];
}

// Format display & bounds (1-decimal K/M style)
function roundedDisplayAndBounds(exact) {
  exact = Math.max(0, Math.floor(exact || 0));
  if (exact >= 1_000_000) {
    const millions = exact / 1_000_000;
    const floored = Math.floor(millions * 10) / 10;
    const lower = Math.floor(floored * 1_000_000);
    const upper = Math.floor((floored + 0.0999999) * 1_000_000) + 999;
    return { display: `${floored.toFixed(1)}M`, lower, upper };
  } else if (exact >= 1000) {
    const thousands = exact / 1000;
    const floored = Math.floor(thousands * 10) / 10;
    const lower = Math.floor(floored * 1000);
    const upper = lower + 999;
    return { display: `${floored.toFixed(1)}K`, lower, upper };
  } else {
    return { display: `${exact}`, lower: 0, upper: 9999 };
  }
}

// API helpers
async function youtubeSearchChannels(q, maxResults=MAX_RESULTS) {
  const url = `https://www.googleapis.com/youtube/v3/search?part=snippet&type=channel&maxResults=${maxResults}&q=${encodeURIComponent(q)}&key=${API_KEY}`;
  const res = await fetch(url);
  if (!res.ok) throw new Error(`Search API ${res.status}`);
  const data = await res.json();
  return data.items || [];
}

async function fetchChannelDetailsByIds(ids) {
  if (!ids.length) return [];
  const url = `https://www.googleapis.com/youtube/v3/channels?part=snippet,statistics&id=${ids.join(",")}&key=${API_KEY}`;
  const res = await fetch(url);
  if (!res.ok) throw new Error(`Channels API ${res.status}`);
  const data = await res.json();
  return data.items || [];
}

// UI wiring
const resultsDiv = el("results");
const searchInput = el("search-input");
const searchBtn = el("search-btn");
const notifyBtn = el("notify-btn");
const countEl = el("count");
const displayedEl = el("displayed");
const speedEl = el("speed");
const roundedEl = el("rounded");
const lastFetchEl = el("last-fetch");
const pauseBtn = el("pause-btn");
const milestonesWrap = el("milestones");
const addMsBtn = el("add-milestone-btn");
const customMsInput = el("custom-milestone-input");
const historyEl = el("history");
const resetMsBtn = el("reset-milestones-btn");

let currentChannel = null; // { id, title }
let state = {
  last_exact: 0, last_rounded: 0, last_rounded_ts: 0, estimated_rate: 0,
  simulated_count: 0, paused: false, triggered: {} // triggered milestones map
};

// Preload default milestones UI
let milestoneList = DEFAULT_MILESTONES.slice(); // numbers
let milestoneEnabled = {}; // map number->bool
milestoneList.forEach(m => milestoneEnabled[m] = true);
function renderMilestones() {
  milestonesWrap.innerHTML = "";
  // sort ascending
  milestoneList.sort((a,b)=>a-b);
  for (const m of milestoneList) {
    const btn = document.createElement("button");
    btn.className = "milestone-btn";
    btn.textContent = (milestoneEnabled[m] ? "ON " : "OFF ") + fmt(m);
    btn.onclick = () => { milestoneEnabled[m] = !milestoneEnabled[m]; renderMilestones(); };
    milestonesWrap.appendChild(btn);
  }
}
renderMilestones();

// Add custom
addMsBtn.onclick = () => {
  const v = parseInt(customMsInput.value.replace(/[, ]/g,""));
  if (!v || v <= 0) { alert("Enter a positive number"); return; }
  if (!milestoneList.includes(v)) {
    milestoneList.push(v); milestoneEnabled[v] = true;
    renderMilestones();
  }
  customMsInput.value = "";
};

// Search flow: search -> fetch details -> compute fuzzy ranking -> display results
searchBtn.onclick = async () => {
  const q = searchInput.value.trim();
  if (!q) return alert("Enter a search term");
  try {
    resultsDiv.textContent = "Loading...";
    const searchResults = await youtubeSearchChannels(q, MAX_RESULTS);
    const ids = searchResults.map(c => c.id.channelId);
    const channels = await fetchChannelDetailsByIds(ids);
    // Sort by fuzzy match to input term
    channels.sort((a,b) => {
      const aName = a.snippet.title || "";
      const bName = b.snippet.title || "";
      return levenshtein(q, aName) - levenshtein(q, bName);
    });
    resultsDiv.innerHTML = "";
    if (channels.length === 0) {
      resultsDiv.textContent = "No results found";
      return;
    }
    for (const ch of channels) {
      const card = document.createElement("div");
      card.className = "channel-card";
      card.onclick = () => loadChannel(ch);
      card.title = ch.snippet.title;
      card.innerHTML = `
        <img src="${ch.snippet.thumbnails.default.url}" alt="avatar"/>
        <div class="channel-meta">
          <div>${ch.snippet.title}</div>
          <div class="small">${ch.statistics.subscriberCount ? fmt(parseInt(ch.statistics.subscriberCount)) + " subs" : "Subs hidden"}</div>
        </div>
      `;
      resultsDiv.appendChild(card);
    }
  } catch(e) {
    resultsDiv.textContent = "Error loading results: " + e.message;
  }
};

function loadChannel(ch) {
  currentChannel = { id: ch.id, title: ch.snippet.title };
  displayedEl.textContent = ch.snippet.title;
  state = loadStateFromLocal(currentChannel.id) || {
    last_exact: parseInt(ch.statistics.subscriberCount) || 0,
    last_rounded: 0,
    last_rounded_ts: 0,
    estimated_rate: 0,
    simulated_count: 0,
    paused: false,
    triggered: {}
  };
  state.simulated_count = state.last_exact;
  updateUI();
  fetchExactCount();
  renderMilestones();
  historyEl.innerHTML = "";
}

// Fetch exact subscriber count periodically
let exactPollTimeout = null;
async function fetchExactCount() {
  if (!currentChannel) return;
  try {
    const url = `https://www.googleapis.com/youtube/v3/channels?part=statistics&id=${currentChannel.id}&key=${API_KEY}`;
    const res = await fetch(url);
    if (!res.ok) throw new Error(`Channels API ${res.status}`);
    const data = await res.json();
    const exactCount = parseInt(data.items[0].statistics.subscriberCount);
    const now = Date.now();
    if (exactCount !== state.last_exact) {
      // update rate estimate
      if (state.last_rounded_ts) {
        const dt = (now - state.last_rounded_ts)/1000;
        const dcount = exactCount - state.last_exact;
        if (dt > 0) state.estimated_rate = dcount/dt;
      }
      // update last exact count
      state.last_exact = exactCount;
      state.simulated_count = exactCount;
      // update rounded milestones
      const rounded = roundedDisplayAndBounds(exactCount);
      state.last_rounded = exactCount;
      state.last_rounded_ts = now;
      // milestone triggers
      checkMilestones(exactCount);
      updateHistory(exactCount);
      saveStateToLocal(currentChannel.id, state);
      updateUI();
    }
  } catch(e) {
    console.error("Fetch exact count error:", e);
  }
  exactPollTimeout = setTimeout(fetchExactCount, POLL_INTERVAL);
}

// Milestones check & notification
function checkMilestones(count) {
  for (const m of milestoneList) {
    if (!milestoneEnabled[m]) continue;
    if (count >= m && !state.triggered[m]) {
      state.triggered[m] = true;
      showNotification(`Milestone reached: ${fmt(m)} subscribers on ${currentChannel.title}! ðŸŽ‰`);
    }
  }
}

// Show notification, request permission if needed
function showNotification(msg) {
  if (!("Notification" in window)) return;
  if (Notification.permission === "granted") {
    new Notification(msg);
  } else if (Notification.permission !== "denied") {
    Notification.requestPermission().then(permission => {
      if (permission === "granted") {
        new Notification(msg);
      }
    });
  }
}

// UI update function
function updateUI() {
  if (!currentChannel) return;
  countEl.textContent = fmt(state.simulated_count);
  speedEl.textContent = state.estimated_rate > 0 ? `${state.estimated_rate.toFixed(1)} subs/sec` : "N/A";
  roundedEl.textContent = roundedDisplayAndBounds(state.simulated_count).display;
  lastFetchEl.textContent = new Date(state.last_rounded_ts).toLocaleTimeString();
  pauseBtn.textContent = state.paused ? "Resume" : "Pause";
  notifyBtn.textContent = Notification.permission === "granted" ? "Notifications ON" : "Notifications OFF";
}

// Simulate count increasing for UI smoothness
setInterval(() => {
  if (!currentChannel || state.paused) return;
  if (state.simulated_count < state.last_exact) state.simulated_count = state.last_exact;
  else state.simulated_count += (state.estimated_rate * (SIM_TICK/1000)) || 0;
  updateUI();
}, SIM_TICK);

// Pause/resume
pauseBtn.onclick = () => {
  if (!currentChannel) return;
  state.paused = !state.paused;
  updateUI();
};

// Notification button - handle permission request & toggle
notifyBtn.onclick = () => {
  if (!("Notification" in window)) {
    alert("This browser does not support notifications.");
    return;
  }
  if (Notification.permission === "granted") {
    // User wants to turn OFF notifications? Can't revoke permission programmatically,
    // so just inform user they can disable via browser settings.
    alert("Notifications are already enabled. To disable, please adjust your browser settings.");
  } else if (Notification.permission === "denied") {
    alert("Notifications are blocked for this site. Please enable them in your browser settings.");
  } else {
    Notification.requestPermission().then(permission => {
      if (permission === "granted") {
        alert("Notifications enabled!");
      } else {
        alert("Notifications not enabled.");
      }
      updateUI();
    });
  }
};

// History tracking (last 10 changes)
function updateHistory(newCount) {
  const nowStr = new Date().toLocaleTimeString();
  const lastEntry = historyEl.firstChild;
  if (lastEntry && lastEntry.dataset.count == newCount) return; // no repeat
  const item = document.createElement("div");
  item.textContent = `${nowStr}: ${fmt(newCount)}`;
  item.dataset.count = newCount;
  historyEl.prepend(item);
  while (historyEl.childNodes.length > 10) historyEl.removeChild(historyEl.lastChild);
}

// Reset milestones to default
resetMsBtn.onclick = () => {
  milestoneList = DEFAULT_MILESTONES.slice();
  milestoneEnabled = {};
  milestoneList.forEach(m => milestoneEnabled[m] = true);
  renderMilestones();
};

/*** Initialization ***/
// Disable buttons until search is done
pauseBtn.disabled = true;
notifyBtn.disabled = false;

// Load last searched channel from local storage
// (Optional) You can implement this if you want to auto-load last channel on page reload

