<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Simulated Live YouTube Sub Counter + Search</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    :root { --bg:#0f1720; --card:#111827; --muted:#9ca3af; --accent:#2563eb; }
    body { margin:0; font-family: Inter, system-ui, Arial; background: linear-gradient(180deg,#071028, #081427); color:#fff; min-height:100vh; display:flex; flex-direction:column; align-items:center; padding:28px; }
    .app { width:100%; max-width:980px; }
    header { display:flex; gap:12px; align-items:center; justify-content:space-between; margin-bottom:18px; }
    h1 { margin:0; font-size:20px; }
    .search-row { display:flex; gap:8px; align-items:center; }
    input[type="text"] { padding:10px 12px; font-size:15px; border-radius:10px; border: none; min-width:280px; }
    button { background:var(--accent); border:none; color:white; padding:9px 12px; border-radius:8px; cursor:pointer; }
    .grid { display:grid; grid-template-columns: 1fr 420px; gap:18px; align-items:start; }
    .panel { background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); padding:14px; border-radius:12px; box-shadow: 0 6px 20px rgba(2,6,23,0.6); }
    .results { display:flex; flex-direction:column; gap:8px; max-height:58vh; overflow:auto; padding-right:6px; }
    .channel-card { display:flex; gap:10px; align-items:center; padding:8px; border-radius:8px; cursor:pointer; transition:background .15s; }
    .channel-card img { width:54px; height:54px; border-radius:50%; object-fit:cover; }
    .channel-card:hover { background:rgba(255,255,255,0.03); }
    .channel-meta { flex:1; text-align:left; }
    .small { color:var(--muted); font-size:13px; }
    #counter-panel { text-align:center; }
    #count { font-size:46px; font-weight:700; letter-spacing:1px; margin:6px 0; }
    #displayed { color:var(--muted); margin-bottom:8px; }
    .status-row { display:flex; gap:8px; justify-content:center; flex-wrap:wrap; color:var(--muted); font-size:13px; }
    .milestones { display:flex; gap:8px; flex-wrap:wrap; margin-top:12px; }
    .milestone-btn { background:#0b1220; border:1px solid rgba(255,255,255,0.04); color:var(--muted); padding:8px 10px; border-radius:8px; cursor:pointer; }
    .banner { position:fixed; left:50%; transform:translateX(-50%); top:18px; background:linear-gradient(90deg,#0f1720,#06223a); border:1px solid rgba(255,255,255,0.06); padding:12px 16px; border-radius:10px; box-shadow:0 8px 30px rgba(0,0,0,0.6); z-index:9999; display:flex; gap:10px; align-items:center; }
    .history { margin-top:10px; color:var(--muted); font-size:13px; max-height:200px; overflow:auto; padding-right:6px; }
    footer { margin-top:18px; color:var(--muted); font-size:13px; text-align:center; }
    .control-row { display:flex; gap:8px; align-items:center; justify-content:center; margin-top:10px; flex-wrap:wrap; }
    label.switch { display:inline-flex; align-items:center; gap:6px; cursor:pointer; color:var(--muted); }
    .checkbox { width:14px; height:14px; border-radius:3px; background:#0b1220; display:inline-block; border:1px solid rgba(255,255,255,0.04); }
    .small-input { width:120px; padding:6px 8px; border-radius:8px; border:none; background:#0b1220; color:#fff; }
  </style>
</head>
<body>
  <div class="app">
    <header>
      <h1>Simulated Live YouTube Sub Counter</h1>
      <div class="search-row">
        <input id="search-input" placeholder="Search for a YouTube channel (name, handle, or ID)" />
        <button id="search-btn">Search</button>
        <button id="notify-btn">Enable Notifications</button>
      </div>
    </header>

    <div class="grid">
      <div class="panel">
        <div style="display:flex;align-items:center;justify-content:space-between;">
          <div style="font-weight:600">Search results</div>
          <div class="small">Tip: click a channel to load its simulated counter</div>
        </div>
        <div id="results" class="results" style="margin-top:10px"></div>
      </div>

      <div class="panel" id="counter-panel">
        <div style="font-weight:600">Live Simulation</div>
        <div id="displayed" class="small">No channel selected</div>
        <div id="count">—</div>
        <div class="status-row" id="status-row">
          <div id="speed">Rate: —</div>
          <div id="rounded">Rounded: —</div>
          <div id="last-fetch">Last API: —</div>
        </div>

        <div style="margin-top:12px; display:flex; gap:8px; justify-content:center; align-items:center;">
          <button id="pause-btn">Pause</button>
          <button id="reset-milestones-btn">Reset milestones for channel</button>
        </div>

        <div style="margin-top:12px; text-align:left;">
          <div style="font-weight:600">Milestones (click to toggle ON/OFF)</div>
          <div class="milestones" id="milestones"></div>

          <div style="margin-top:8px;">
            <input id="custom-milestone-input" class="small-input" placeholder="Custom (e.g., 75000)" />
            <button id="add-milestone-btn" class="milestone-btn">Add milestone</button>
          </div>

          <div style="margin-top:10px;">
            <div style="font-weight:600">Milestone history</div>
            <div id="history" class="history"></div>
          </div>
        </div>
      </div>
    </div>

    <footer>
      Built for GitHub Pages • Keep API key restricted to your site (instructions below)
    </footer>
  </div>

  <script>
  /****************** CONFIG - change these if you like ******************/
  const API_KEY = "AIzaSyCW77DSG7O7oowEV_iOg0K_wgJjBzM8Lzs"; // <- REPLACE with your key
  const MAX_RESULTS = 8;                   // search results to show
  const POLL_INTERVAL = 1_000;            // ms between exact API polls
  const SIM_TICK = 5000;                   // ms between UI simulation ticks
  const DEFAULT_MILESTONES = [10000, 50000, 100000, 250000, 500000, 1000000];
  /************************************************************************/

  // utils
  const el = id => document.getElementById(id);
  const fmt = n => (typeof n === "number") ? n.toLocaleString() : n;

  // safe storage helpers
  const storageKey = cid => `yt_sim_state_${cid}`;
  function saveStateToLocal(channelId, state) {
    try { localStorage.setItem(storageKey(channelId), JSON.stringify(state)); } catch(e) {}
  }
  function loadStateFromLocal(channelId) {
    try { const s = localStorage.getItem(storageKey(channelId)); return s ? JSON.parse(s) : null; } catch(e){ return null; }
  }

  // Levenshtein distance (for fuzzy sorting)
  function levenshtein(a, b) {
    a = (a||"").toLowerCase(); b = (b||"").toLowerCase();
    if (a === b) return 0;
    const m = a.length, n = b.length;
    const dp = Array.from({length: m+1}, () => new Array(n+1));
    for (let i=0;i<=m;i++) dp[i][0] = i;
    for (let j=0;j<=n;j++) dp[0][j] = j;
    for (let i=1;i<=m;i++){
      for (let j=1;j<=n;j++){
        dp[i][j] = Math.min(
          dp[i-1][j] + 1,
          dp[i][j-1] + 1,
          dp[i-1][j-1] + (a[i-1]===b[j-1] ? 0 : 1)
        );
      }
    }
    return dp[m][n];
  }

  // Format display & bounds (1-decimal K/M style)
  function roundedDisplayAndBounds(exact) {
    exact = Math.max(0, Math.floor(exact || 0));
    if (exact >= 1_000_000) {
      const millions = exact / 1_000_000;
      const floored = Math.floor(millions * 10) / 10;
      const lower = Math.floor(floored * 1_000_000);
      const upper = Math.floor((floored + 0.0999999) * 1_000_000) + 999;
      return { display: `${floored.toFixed(1)}M`, lower, upper };
    } else if (exact >= 1000) {
      const thousands = exact / 1000;
      const floored = Math.floor(thousands * 10) / 10;
      const lower = Math.floor(floored * 1000);
      const upper = lower + 999;
      return { display: `${floored.toFixed(1)}K`, lower, upper };
    } else {
      return { display: `${exact}`, lower: 0, upper: 9999 };
    }
  }

  // API helpers
  async function youtubeSearchChannels(q, maxResults=MAX_RESULTS) {
    const url = `https://www.googleapis.com/youtube/v3/search?part=snippet&type=channel&maxResults=${maxResults}&q=${encodeURIComponent(q)}&key=${API_KEY}`;
    const res = await fetch(url);
    if (!res.ok) throw new Error(`Search API ${res.status}`);
    const data = await res.json();
    return data.items || [];
  }

  async function fetchChannelDetailsByIds(ids) {
    if (!ids.length) return [];
    const url = `https://www.googleapis.com/youtube/v3/channels?part=snippet,statistics&id=${ids.join(",")}&key=${API_KEY}`;
    const res = await fetch(url);
    if (!res.ok) throw new Error(`Channels API ${res.status}`);
    const data = await res.json();
    return data.items || [];
  }

  // UI wiring
  const resultsDiv = el("results");
  const searchInput = el("search-input");
  const searchBtn = el("search-btn");
  const notifyBtn = el("notify-btn");
  const countEl = el("count");
  const displayedEl = el("displayed");
  const speedEl = el("speed");
  const roundedEl = el("rounded");
  const lastFetchEl = el("last-fetch");
  const pauseBtn = el("pause-btn");
  const milestonesWrap = el("milestones");
  const addMsBtn = el("add-milestone-btn");
  const customMsInput = el("custom-milestone-input");
  const historyEl = el("history");
  const resetMsBtn = el("reset-milestones-btn");

  let currentChannel = null; // { id, title }
  let state = {
    last_exact: 0, last_rounded: 0, last_rounded_ts: 0, estimated_rate: 0,
    simulated_count: 0, paused: false, triggered: {} // triggered milestones map
  };

  // Preload default milestones UI
  let milestoneList = DEFAULT_MILESTONES.slice(); // numbers
  let milestoneEnabled = {}; // map number->bool
  milestoneList.forEach(m => milestoneEnabled[m] = true);
  function renderMilestones() {
    milestonesWrap.innerHTML = "";
    // sort ascending
    milestoneList.sort((a,b)=>a-b);
    for (const m of milestoneList) {
      const btn = document.createElement("button");
      btn.className = "milestone-btn";
      btn.textContent = (milestoneEnabled[m] ? "ON " : "OFF ") + fmt(m);
      btn.onclick = () => { milestoneEnabled[m] = !milestoneEnabled[m]; renderMilestones(); };
      milestonesWrap.appendChild(btn);
    }
  }
  renderMilestones();

  // Add custom
  addMsBtn.onclick = () => {
    const v = parseInt(customMsInput.value.replace(/[, ]/g,""));
    if (!v || v <= 0) { alert("Enter a positive number"); return; }
    if (!milestoneList.includes(v)) {
      milestoneList.push(v); milestoneEnabled[v] = true;
      renderMilestones();
    }
    customMsInput.value = "";
  };

  // Search flow: search -> fetch details -> compute fuzzy distance -> show list
  async function doSearch() {
    const q = searchInput.value.trim();
    if (!q) return;
    resultsDiv.innerHTML = "<div class='small'>Searching...</div>";
    try {
      const items = await youtubeSearchChannels(q, MAX_RESULTS);
      const ids = items.map(it => it.snippet.channelId).filter(Boolean);
      const details = await fetchChannelDetailsByIds(ids);
      // map id->details
      const map = {};
      for (const d of details) {
        const id = d.id;
        map[id] = {
          id,
          title: d.snippet.title,
          thumbnail: (d.snippet.thumbnails && (d.snippet.thumbnails.medium || d.snippet.thumbnails.default)).url,
          subs: (d.statistics && d.statistics.subscriberCount) ? parseInt(d.statistics.subscriberCount) : 0,
          desc: d.snippet.description || ""
        };
      }
      // combine items (some search items may be lacking details if private, so filter)
      const results = ids.map(id => map[id]).filter(Boolean);
      // compute distance + sort ascending (closer first), tie-break: higher subs
      results.forEach(r => r.distance = levenshtein(q.toLowerCase(), (r.title||"").toLowerCase()));
      results.sort((a,b)=> (a.distance - b.distance) || (b.subs - a.subs));
      renderSearchResults(results, q);
    } catch (err) {
      console.error(err);
      resultsDiv.innerHTML = `<div class="small">Error: ${err.message}</div>`;
    }
  }

  function renderSearchResults(results, query) {
    resultsDiv.innerHTML = "";
    if (!results.length) { resultsDiv.innerHTML = `<div class="small">No channels found for "${query}"</div>`; return; }
    for (const r of results) {
      const card = document.createElement("div");
      card.className = "channel-card";
      card.innerHTML = `
        <img src="${r.thumbnail}" alt="avatar">
        <div class="channel-meta">
          <div style="font-weight:600">${r.title}</div>
          <div class="small">${fmt(r.subs)} subscribers • match ${r.distance}</div>
        </div>
        <div style="display:flex;flex-direction:column;gap:6px">
          <button class="small-btn">Load</button>
        </div>
      `;
      card.querySelector("button").onclick = () => loadChannel(r.id, r.title);
      resultsDiv.appendChild(card);
    }
  }

  // Load a channel into simulation
  async function loadChannel(channelId, title) {
    currentChannel = { id: channelId, title: title || channelId };
    displayedEl.textContent = `Channel: ${currentChannel.title}`;
    // try to restore saved state
    const saved = loadStateFromLocal(channelId);
    if (saved) {
      state = Object.assign(state, saved);
      // ensure simulated_count at least last_exact
      state.simulated_count = Math.max(state.simulated_count || 0, saved.last_exact || 0);
    } else {
      // fetch fresh exact subs now
      await pollApiOnce(true);
      state.simulated_count = state.last_exact || 0;
    }
    updateUIFields();
    addToHistory(`Loaded ${currentChannel.title}`);
  }

  // single API fetch for currentChannel (used on load and periodic poll)
  async function pollApiOnce(force=false) {
    if (!currentChannel) return;
    // local caching guard
    const now = Date.now();
    if (!force && state.last_api_fetch && (now - (state.last_api_fetch || 0) < POLL_INTERVAL - 2000)) {
      return; // still fresh
    }

    try {
      const items = await fetchChannelDetailsByIds([currentChannel.id]);
      if (!items.length) return;
      const info = items[0];
      const subs = (info.statistics && info.statistics.subscriberCount) ? parseInt(info.statistics.subscriberCount) : 0;
      const prevRounded = state.last_rounded || 0;
      const rd = roundedDisplayAndBounds(subs);
      const roundedRep = rd.lower;
      // initial setup
      if (!state.last_rounded) {
        state.last_rounded = roundedRep;
        state.last_rounded_ts = Date.now();
        state.estimated_rate = 0;
      } else if (roundedRep !== state.last_rounded) {
        const timeTaken = Math.max(1, (Date.now() - (state.last_rounded_ts || Date.now())) / 1000);
        const delta = Math.abs(roundedRep - (state.last_rounded || 0));
        const subs_per_sec = delta / timeTaken;
        // smoothing
        state.estimated_rate = ( (state.estimated_rate || 0) * 0.5 ) + (subs_per_sec * 0.5);
        state.last_rounded = roundedRep;
        state.last_rounded_ts = Date.now();
      }
      state.last_exact = subs;
      state.last_api_fetch = Date.now();
      saveStateToLocal(currentChannel.id, state);
      updateUIFields();
    } catch (err) {
      console.error("poll error", err);
      addToHistory("API error: " + (err.message||err));
    }
  }

  // UI update helper
  function updateUIFields() {
    speedEl.textContent = `Rate: ${(state.estimated_rate || 0).toFixed(3)} subs/sec`;
    const rd = roundedDisplayAndBounds(state.last_exact || Math.floor(state.simulated_count||0));
    roundedEl.textContent = `Rounded: ${rd.display}`;
    lastFetchEl.textContent = `Last API: ${state.last_api_fetch ? new Date(state.last_api_fetch).toLocaleTimeString() : "—"}`;
    countEl.textContent = fmt(Math.floor(state.simulated_count || 0));
  }

  // simulation tick
  function simTick() {
    if (!currentChannel || state.paused) return;
    const base_rate = Math.max(state.estimated_rate || 0.01, 0.01);
    const noise = (Math.random() * 0.4) + 0.8;
    let inc = base_rate * (SIM_TICK/1000) * noise;

    // occasional spike
    if (Math.random() < 0.025) inc *= (Math.random() * 3 + 1);
    // occasional small drop
    if (Math.random() < 0.02 && state.simulated_count > 50) state.simulated_count -= Math.random() * 12;

    state.simulated_count += inc;

    // clamp with bounds derived from last_exact
    const rd = roundedDisplayAndBounds(state.last_exact || Math.floor(state.simulated_count || 0));
    const lowerBound = Math.max(rd.lower - 80, 0);
    const upperBound = rd.upper + 20;
    if (state.simulated_count > upperBound) state.simulated_count = upperBound - Math.random() * 12;
    if (state.simulated_count < lowerBound) state.simulated_count = lowerBound + Math.random()*6;

    // check milestones
    checkMilestones();

    updateUIFields();
  }

  // milestone logic
  function checkMilestones() {
    if (!currentChannel) return;
    for (const m of milestoneList) {
      if (!milestoneEnabled[m]) continue;
      if (state.triggered && state.triggered[m]) continue;
      if (state.simulated_count >= m) {
        // trigger
        state.triggered[m] = true;
        saveStateToLocal(currentChannel.id, state);
        triggerMilestone(m);
      }
    }
  }

  // show banner + notification + history entry
  function triggerMilestone(m) {
    const text = `${currentChannel.title} hit ${fmt(m)} subscribers!`;
    showBanner(text);
    addToHistory(text);
    // browser notification if allowed
    if (window.Notification && Notification.permission === "granted") {
      new Notification("Milestone!", { body: text, icon: "" });
    } else {
      // do nothing if no permission
    }
    // small beep using WebAudio
    try {
      const ctx = new (window.AudioContext || window.webkitAudioContext)();
      const o = ctx.createOscillator();
      const g = ctx.createGain();
      o.type = 'sine';
      o.frequency.value = 880;
      g.gain.value = 0.00001;
      o.connect(g); g.connect(ctx.destination);
      o.start();
      g.gain.exponentialRampToValueAtTime(0.2, ctx.currentTime + 0.02);
      g.gain.exponentialRampToValueAtTime(0.00001, ctx.currentTime + 0.45);
      o.stop(ctx.currentTime + 0.5);
    } catch(e){}
  }

  // small floating banner
  function showBanner(text) {
    const b = document.createElement("div");
    b.className = "banner";
    b.textContent = text;
    document.body.appendChild(b);
    setTimeout(()=>{ b.style.opacity = 0; b.remove(); }, 7000);
  }

  function addToHistory(text) {
    const row = document.createElement("div");
    row.textContent = `${new Date().toLocaleTimeString()} — ${text}`;
    historyEl.prepend(row);
  }

  // Notification permission button
  notifyBtn.onclick = async () => {
    if (!("Notification" in window)) { alert("Notifications not supported by this browser."); return; }
    if (Notification.permission === "granted") {
      alert("Notifications already enabled.");
      return;
    }
    const p = await Notification.requestPermission();
    if (p === "granted") alert("Notifications enabled. Milestones will send notifications.");
    else alert("Notifications blocked or denied; you can still see on-page banners.");
  };

  // pause button
  pauseBtn.onclick = () => {
    state.paused = !state.paused;
    pauseBtn.textContent = state.paused ? "Resume" : "Pause";
    addToHistory(state.paused ? "Simulation paused" : "Simulation resumed");
  };

  // reset per-channel milestones
  resetMsBtn.onclick = () => {
    if (!currentChannel) return;
    state.triggered = {};
    saveStateToLocal(currentChannel.id, state);
    addToHistory("Milestones reset for " + currentChannel.title);
  };

  // main loops
  searchBtn.onclick = doSearch;
  searchInput.addEventListener("keydown", (e) => { if (e.key === "Enter") doSearch(); });

  // poll API periodically (for current channel)
  setInterval(() => {
    if (!currentChannel) return;
    pollApiOnce(false);
  }, POLL_INTERVAL);

  // simulation ticks
  setInterval(simTick, SIM_TICK);

  // page load: simple hint
  addToHistory("Ready. Type a channel name and press Search.");

  </script>
</body>
</html>
